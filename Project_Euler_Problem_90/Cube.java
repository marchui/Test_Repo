/*
 *	Designer: Marcus Hui
 *  Date: Jul 12, 2011
 * 	Description: This program is used to calculate the number of distinct arrangements of the square 
 * 				 numbers smaller than 100 between two cubes. The exercise was given to me by Brian Bird 
 * 				 of InsideVault. I choose a semi-brute force approach to solve this problem. I first 
 * 				 create a list of all possible number combinations that can appear on a 6 face cube, 
 * 				 the numbers are between 0 to 9. Once the list of all possible number combinations is 
 * 				 generated, I then compare the combinations one by one to see if both cubes contain 
 * 				 the numbers required to fulfill the specification. 
 * 
 * 
 * Project Euler Description:
 * Each of the six faces on a cube has a different digit (0 to 9) written on it; the same is done to a second cube. 
 * By placing the two cubes side-by-side in different positions we can form a variety of 2-digit numbers.
 * 
 * For example, the square number 64 could be formed: [6][4]
 * 
 * In fact, by carefully choosing the digits on both cubes it is possible to display all of the square numbers below 
 * one-hundred: 01, 04, 09, 16, 25, 36, 49, 64, and 81.
 * 
 * For example, one way this can be achieved is by placing {0, 5, 6, 7, 8, 9} on one cube and {1, 2, 3, 4, 8, 9} on the other cube.
 * 
 * However, for this problem we shall allow the 6 or 9 to be turned upside-down so that an arrangement like {0, 5, 6, 7, 8, 9} and 
 * {1, 2, 3, 4, 6, 7} allows for all nine square numbers to be displayed; otherwise it would be impossible to obtain 09.
 * 
 * In determining a distinct arrangement we are interested in the digits on each cube, not the order.
 * 
 * {1, 2, 3, 4, 5, 6} is equivalent to {3, 6, 4, 1, 2, 5}
 * {1, 2, 3, 4, 5, 6} is distinct from {1, 2, 3, 4, 5, 9}
 * 
 * But because we are allowing 6 and 9 to be reversed, the two distinct sets in the last example both represent the extended 
 * set {1, 2, 3, 4, 5, 6, 9} for the purpose of forming 2-digit numbers.
 * 
 * How many distinct arrangements of the two cubes allow for all of the square numbers to be displayed?
 */

import java.util.*;
import java.lang.*;
import java.io.*;

class Cube
{
	//
	// This is the main method that start this program.
	//
	public static void main(String arg[])
	{
		ArrayList <Object[]> cubeList = new ArrayList<Object[]>();
		ArrayList <String> resultList = new ArrayList<String>();

		cubeList = getCubeList();
		resultList = getResultList(cubeList);
		System.out.println("The number of distinct arrangements is : " + resultList.size());

		try
		{
			System.out.print("Would you like the see the list of distinct cube arrangements? ");
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			String input = br.readLine();
			if(input.length() > 0 && (input.charAt(0) == 'y' || input.charAt(0) == 'Y'))
				displayResultListContent(resultList);
		}
		catch(IOException ee)
		{
			System.out.println("Error reading input: " + ee.toString());
		}
	}


	//
	// This method is used to generate a list of possible cube combinations. The List will
	// contain all possible face values of a cube. The list will not contain duplicates 
	// and all results are sorted. The method will return an ArrayList of Integer object 
	// arrays. 
	//
	private static ArrayList<Object[]> getCubeList()
	{
		ArrayList<Integer> al = new ArrayList<Integer>(6);
		ArrayList<Object[]> cuList = new ArrayList<Object[]>();
		String endCondition = "[4, 5, 6, 7, 8, 9]";
		final int alindex = 5;

		for (int a = 0; a < 6; a++)
			al.add(a);
		cuList.add(al.toArray());

		while(!al.toString().equals(endCondition))
		{
			if(al.get(alindex) >= 9)
			{
				int tempInt, i = alindex;

				for(int tempindex = 9; i >= 0 && al.get(i) == tempindex; tempindex--)
					i--;

				if(i >= 0)
				{
					tempInt = (al.get(i)).intValue();

					for(; i < 6; i++)
							al.set(i, ++tempInt);
				}
			}
			else
				al.set(alindex, al.get(alindex) + 1);

			if(!cuList.contains(al.toArray()))
				cuList.add(al.toArray());
		}

		return cuList;
	}


	//
	// This method is used to get a list of distinct cube arrangements. The cube list what
	// was generated by the getCubeList() method will be send here to get the total number
	// of distinct two cube arrangements. The result in the from of an ArrayList of String 
	// objects will be return. 
	//
	private static ArrayList<String> getResultList(ArrayList<Object[]> cList)
	{
		ArrayList <String> rList = new ArrayList<String>();

		for(Object[] cubeAryA : cList)
			for(Object[] cubeAryB : cList)
			{
				// 01
				if(!((Arrays.binarySearch(cubeAryA, 0) >= 0 && Arrays.binarySearch(cubeAryB, 1) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 1) >= 0 && Arrays.binarySearch(cubeAryB, 0) >= 0)))
					continue;

				// 04
				if(!((Arrays.binarySearch(cubeAryA, 0) >= 0 && Arrays.binarySearch(cubeAryB, 4) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 4) >= 0 && Arrays.binarySearch(cubeAryB, 0) >= 0)))
					continue;

				// 09 or 06
				if(!((Arrays.binarySearch(cubeAryA, 0) >= 0 && Arrays.binarySearch(cubeAryB, 9) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 9) >= 0 && Arrays.binarySearch(cubeAryB, 0) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 0) >= 0 && Arrays.binarySearch(cubeAryB, 6) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 6) >= 0 && Arrays.binarySearch(cubeAryB, 0) >= 0)))
					continue;

				// 16 or 19
				if(!((Arrays.binarySearch(cubeAryA, 1) >= 0 && Arrays.binarySearch(cubeAryB, 6) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 6) >= 0 && Arrays.binarySearch(cubeAryB, 1) >= 0) ||
				   (Arrays.binarySearch(cubeAryA, 1) >= 0 && Arrays.binarySearch(cubeAryB, 9) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 9) >= 0 && Arrays.binarySearch(cubeAryB, 1) >= 0)))
					continue;

				// 25
				if(!((Arrays.binarySearch(cubeAryA, 2) >= 0 && Arrays.binarySearch(cubeAryB, 5) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 5) >= 0 && Arrays.binarySearch(cubeAryB, 2) >= 0)))
					continue;

				// 36 or 39
				if(!((Arrays.binarySearch(cubeAryA, 3) >= 0 && Arrays.binarySearch(cubeAryB, 6) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 6) >= 0 && Arrays.binarySearch(cubeAryB, 3) >= 0) ||
				   (Arrays.binarySearch(cubeAryA, 3) >= 0 && Arrays.binarySearch(cubeAryB, 9) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 9) >= 0 && Arrays.binarySearch(cubeAryB, 3) >= 0)))
					continue;

				// 49 or 46
				if(!((Arrays.binarySearch(cubeAryA, 4) >= 0 && Arrays.binarySearch(cubeAryB, 9) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 9) >= 0 && Arrays.binarySearch(cubeAryB, 4) >= 0) ||
				   (Arrays.binarySearch(cubeAryA, 4) >= 0 && Arrays.binarySearch(cubeAryB, 6) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 6) >= 0 && Arrays.binarySearch(cubeAryB, 4) >= 0)))
					continue;

				// 64 or 94
				if(!((Arrays.binarySearch(cubeAryA, 6) >= 0 && Arrays.binarySearch(cubeAryB, 4) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 4) >= 0 && Arrays.binarySearch(cubeAryB, 6) >= 0) ||
				   (Arrays.binarySearch(cubeAryA, 9) >= 0 && Arrays.binarySearch(cubeAryB, 4) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 4) >= 0 && Arrays.binarySearch(cubeAryB, 9) >= 0)))
					continue;

				// 81
				if(!((Arrays.binarySearch(cubeAryA, 8) >= 0 && Arrays.binarySearch(cubeAryB, 1) >= 0) || 
				   (Arrays.binarySearch(cubeAryA, 1) >= 0 && Arrays.binarySearch(cubeAryB, 8) >= 0)))
					continue;

				//Saving the qualified result to the result list.
				if(!rList.contains(Arrays.toString(cubeAryA) + " " + Arrays.toString(cubeAryB)) && 
				   !rList.contains(Arrays.toString(cubeAryB) + " " + Arrays.toString(cubeAryA)))
					rList.add(Arrays.toString(cubeAryA) + " " + Arrays.toString(cubeAryB));
			}
		
		return rList;
	}


	//
	// This method will display the result list on standard output. The user have a choice
	// to display or ignore the result from the main method. If the user choose to display
	// the results, the list of string values that contain all the distinct arrangement will
	// be display on screen.
	//
	private static void displayResultListContent(ArrayList<String> ruList)
	{
		System.out.println("\n\nThe following is a list of all distinct cube arrangements; ");
		for(String outputStr : ruList)
			System.out.println(outputStr);
	}
}
